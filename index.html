<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Our Scrapbook - Nathan & Hannah</title>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css" rel="stylesheet">
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
	<script src="/auth-guard.js"></script>
	<style>
		.memory {
			transition: all 0.3s ease-in-out;
			transform-origin: center;
		}

		.memory-overlay {
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
			/* Let JS set the gradient via style.background */
			background: transparent;
			/* Optional: give gradients a bit more punch with blend modes */
			/* mix-blend-mode: multiply; */
		}

		.memory-overlay.active {
			opacity: 1;
			visibility: visible;
		}

		.memory img {
			transition: all 0.3s ease-in-out;
		}

		.memory.active img {
			filter: brightness(0.7);
		}

		@media (hover: hover) and (pointer: fine) {
			.memory[data-aos].aos-animate:hover {
				transform: translate3d(0, 0, 0) scale(1.05) !important;
				z-index: 10;
			}

			.memory:hover .memory-overlay {
				opacity: 1;
				visibility: visible;
			}

			.memory:hover img {
				filter: brightness(0.7);
			}
		}

		@media (hover: none) and (pointer: coarse) {
			.memory.active {
				transform: scale(1.05) !important;
				z-index: 10;
			}
		}

		[data-aos][data-aos].aos-animate {
			transform: translate3d(0, 0, 0);
		}

		/* Add Memory Card Styles - smoother transitions */
		.add-memory-card {
			border: 2px dashed #d1d5db;
			background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(248, 248, 248, 0.8) 100%);
			backdrop-filter: blur(10px);
			transition: transform 360ms cubic-bezier(.22,1,.36,1), box-shadow 360ms cubic-bezier(.22,1,.36,1), border-color 360ms ease, background 360ms ease;
			transform-origin: center;
			cursor: pointer;
			min-height: 300px;
			will-change: transform, box-shadow;
			position: relative;
		}

		.add-memory-card:hover {
			border-color: #9ca3af;
			background: linear-gradient(135deg, rgba(248, 248, 248, 0.95) 0%, rgba(240, 240, 240, 0.95) 100%);
			transform: translateY(-4px) scale(1.01);
			box-shadow: 0 12px 40px rgba(0,0,0,0.08);
		}

		/* Expanded state: subtle lift + stronger highlight rather than abrupt grid-jump */
		.add-memory-card.expanded {
			/* Keep layout changes minimal; visually emphasize with transform and shadow */
			transform: translateY(-6px) scale(1.02);
			border: 2px solid #3b82f6;
			background: rgba(255, 255, 255, 0.97);
			backdrop-filter: blur(14px);
			box-shadow: 0 20px 60px rgba(59,130,246,0.12);
			z-index: 30;
		}

		@media (max-width: 768px) {
			/* On smaller screens allow the card to occupy the full width but keep a smooth visual change */
			.add-memory-card.expanded {
				transform: none;
				border-color: #3b82f6;
				box-shadow: 0 12px 36px rgba(59,130,246,0.10);
			}
		}

		.add-memory-content {
			transition: opacity 220ms ease-in-out, transform 260ms ease-in-out;
		}

		/* Use transform + opacity for the form reveal for smoother, compositor-driven animation */
		.add-memory-form {
			opacity: 0;
			transform: translateY(6px) scaleY(.99);
			height: 0;
			overflow: hidden;
			transition: opacity 300ms ease, transform 300ms cubic-bezier(.22,1,.36,1), height 320ms ease;
			pointer-events: none;
		}

		/* Loading bar for add-memory interactions */
		.add-loading { transition: width 480ms cubic-bezier(.22,1,.36,1); height: 4px; border-radius: 2px; }

		.add-memory-card.expanded .add-memory-form {
			opacity: 1;
			transform: translateY(0) scaleY(1);
			height: auto; /* allow it to open; small jump is less jarring when opacity+transform animate */
			pointer-events: auto;
		}

		.add-memory-card.expanded .add-memory-content {
			opacity: 0;
			transform: translateY(-6px);
		}

		/* Respect reduced motion preferences */
		@media (prefers-reduced-motion: reduce) {
			.add-memory-card, .add-memory-form, .add-memory-content { transition: none !important; }
		}

		/* New gradient background system */
		:root{
			/* tweak these three to re-theme quickly */
			--bg-start: #face95;   /* warm cream/orange */
			--bg-end:   #f0dba6;   /* soft yellow */
			--brand:    #f8c788;   /* orange accent */
			/* timeline theme tokens (red -> orange) */
			--tl-bg-start: #ef4444; /* red */
			--tl-bg-end:   #f59e0b; /* orange */
			--tl-accent:   #fb923c; /* accent */
		}

		/* Page background = larger, lower radial gradients so color reaches further down the page */
		body {
			background:
				radial-gradient(1600px 2500px at 10% 0%, var(--bg-start) 0%, transparent 60%),
				radial-gradient(1600px 2500px at 90% 10%,  var(--bg-end) 0%, transparent 65%),
				linear-gradient(180deg, #ffffff 6%, #fafbff 100%);
			position: relative;
			min-height: 140vh; /* increase baseline to encourage gradients to cover longer pages */
		}

		/* Tiny noise texture to avoid flatness (data-uri, no file needed) */
		body::before{
			content:"";
			position: fixed;
			inset: 0;
			pointer-events: none;
			background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/><feColorMatrix type='saturate' values='0'/><feComponentTransfer><feFuncA type='table' tableValues='0 0 0 0 .015 .03 0 0 0'/></feComponentTransfer></filter><rect width='120' height='120' filter='url(%23n)'/></svg>");
			background-size: 300px 300px;
			opacity: .35; /* subtle! */
			mix-blend-mode: multiply;
		}

		/* Filter bar segmented control active state */
		#filter-bar button[aria-pressed="true"]{
			background: #ffffff;
			box-shadow: 0 8px 24px rgba(0,0,0,0.06);
			color: #0f172a;
			border: 1px solid rgba(0,0,0,0.06);
		}

		/* Timeline button styling (larger gradient CTA) */
		.timeline-btn{
			background: linear-gradient(90deg, var(--tl-bg-start) 0%, var(--tl-bg-end) 100%);
			box-shadow: 0 10px 30px rgba(239,68,68,0.12);
		}

		.timeline-btn:hover{
			filter: brightness(1.03);
		}

		.timeline-btn:focus{
			outline: none;
			box-shadow: 0 0 0 4px rgba(251,146,60,0.12);
		}

		/* Attribution overlay visibility when card is active on mobile */
		.memory.active .attribution-overlay { opacity: 1; }
	</style>
</head>

<body>
	<header class="relative">
		<!-- decorative gradient blob -->
		<div aria-hidden="true" class="pointer-events-none absolute inset-x-0 -top-24 h-72
					bg-gradient-to-r from-orange-200 via-amber-200 to-yellow-200 blur-3xl opacity-60"></div>

		<div class="relative mx-auto max-w-5xl px-6 pt-20 pb-8">
			<!-- Glass card -->
			<div class="backdrop-blur-md bg-white/50 rounded-2xl shadow-[0_10px_30px_rgba(0,0,0,.08)] ring-1 ring-white/60">
				<div class="px-8 py-7 text-center">
					<h1 class="text-4xl md:text-5xl font-extrabold tracking-tight text-slate-900">
						Our Scrapbook <span aria-hidden="true">ðŸ§¡</span>
					</h1>
					<p class="mt-3 text-slate-600 max-w-2xl mx-auto">
						A collection of our favorite momentsâ€”curated with love.
					</p>

					<!-- buttons -->
					<div class="mt-5 flex justify-center gap-3">
						<a href="/legacy.html"
							 class="inline-flex items-center rounded-xl px-5 py-2.5 text-gray-800 font-medium
									bg-[var(--brand)] hover:opacity-50 focus:outline-none focus:ring-2
									focus:ring-offset-2 focus:ring-gray-300 transition border border-gray-200">
							Visit the old site
						</a>
						<!-- <a href="/timeline.html"
							 class="inline-flex items-center rounded-xl px-5 py-2.5 text-gray-800 font-medium
									bg-[var(--brand)] hover:opacity-60 focus:outline-none focus:ring-2
									focus:ring-offset-2 focus:ring-[var(--brand)] transition">
							View Timeline
						</a> -->
						<a href="/good-morning.html"
							 class="inline-flex items-center rounded-xl px-5 py-2.5 text-gray-800 font-medium
									bg-[var(--brand)] hover:opacity-40 focus:outline-none focus:ring-2
									focus:ring-offset-2 focus:ring-[var(--brand)] transition">
							Good Morning
						</a>
					</div>
					<!-- Timeline -->
					<div class="mt-6 flex justify-center gap-3">
						<a href="/timeline.html"
						 	 class="timeline-btn inline-flex items-center rounded-2xl px-8 py-4 text-white text-lg font-semibold shadow-lg transform hover:-translate-y-0.5 transition">
								View Timeline
							</a>
					</div>
				</div>
			</div>
		</div>
	</header>

	<!-- Filters -->
	<div class="mx-auto max-w-5xl px-6 -mt-4">
		<div id="filter-bar" class="flex flex-wrap items-center justify-center gap-3 bg-white/70 backdrop-blur rounded-2xl px-3 py-1 ring-0">
			<!-- Author segmented -->
			<div class="flex items-center gap-1" role="group" aria-label="Filter by author">
				<button type="button" data-by="all" aria-pressed="true" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">All</button>
				<button type="button" data-by="hannah" aria-pressed="false" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">Hannah</button>
				<button type="button" data-by="nathan" aria-pressed="false" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">Nathan</button>
				<button type="button" data-by="both" aria-pressed="false" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">Both</button>
			</div>
			<div class="w-full md:w-auto flex justify-center items-center">
				<div class="hidden md:block h-6 w-px bg-black/10"></div>
				<div class="md:hidden h-px w-12 bg-black/10"></div>
			</div>
			<!-- Sort segmented -->
			<div class="flex items-center gap-1" role="group" aria-label="Sort">
				<button type="button" data-sort="oldest" aria-pressed="true" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">Latest</button>
				<button type="button" data-sort="newest" aria-pressed="false" class="px-3 py-1.5 rounded-xl text-sm font-medium text-slate-700 hover:bg-white focus:outline-none focus-visible:ring-2 focus-visible:ring-sky-400">Earliest</button>
			</div>
			<div class="w-full md:w-auto flex justify-center items-center">
				<div class="hidden md:block h-6 w-px bg-black/10"></div>
				<div class="md:hidden h-px w-12 bg-black/10"></div>
			</div>
			<!-- Date range -->
			<div class="flex flex-wrap items-center justify-center gap-2">
				<label class="text-sm text-slate-600 flex justify-center items-center gap-2 w-full sm:w-auto">After
					<input type="date" id="filter-after" class="rounded-md border border-slate-200 px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400" />
				</label>
				<label class="text-sm text-slate-600 flex justify-center items-center gap-2 w-full sm:w-auto">Before
					<input type="date" id="filter-before" class="rounded-md border border-slate-200 px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400" />
				</label>
			</div>
		</div>
	</div>

	<main class="container mx-auto py-10 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 px-4" id="memories-grid">
		<!-- Dynamic memories will be loaded here -->
	</main>

	<footer class="text-center py-4">Made with ðŸ§¡ by Nathan for Hannah</footer>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.js"></script>
	<script>
		AOS.init({ once: false, duration: 1000, easing: 'ease-out-cubic' });

		const isTouchDevice = () => (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
		let lastClickedMemory = null;

		function isInViewport(element) {
			const rect = element.getBoundingClientRect();
			return (rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth));
		}

		function resetMemory(memory) {
			memory.classList.remove('active');
			const overlay = memory.querySelector('.memory-overlay');
			if (overlay) {
				overlay.classList.remove('active');
			}
		}

		function initializeMemoryInteractions() {
			const grid = document.getElementById('memories-grid');

			// Avoid re-binding listeners if already initialized
			if (grid.dataset.interactions === '1') {
				// still ensure scroll handler is set
				window.removeEventListener('scroll', handleScrollForMemories);
				window.addEventListener('scroll', handleScrollForMemories);
				return;
			}

			if (isTouchDevice()) {
				// For touch devices - use click to toggle
				grid.addEventListener('click', function (e) {
					const mem = e.target.closest('.memory');
					if (!mem) return;
					// Prevent default if clicking on the overlay
					e.preventDefault();
					// Reset previous memory if exists
					if (lastClickedMemory && lastClickedMemory !== mem) resetMemory(lastClickedMemory);
					// Toggle current memory
					mem.classList.toggle('active');
					const overlay = mem.querySelector('.memory-overlay');
					if (overlay) overlay.classList.toggle('active');
					lastClickedMemory = mem.classList.contains('active') ? mem : null;
				});
				
				// Remove existing scroll listeners and add new one
				window.removeEventListener('scroll', handleScrollForMemories);
				window.addEventListener('scroll', handleScrollForMemories);
			} else {
				// For desktop - use hover effects  
				grid.addEventListener('mouseleave', function (e) {
					const mem = e.target.closest('.memory');
					if (mem) resetMemory(mem);
				});
			}

			// mark as initialized so we don't rebind
			grid.dataset.interactions = '1';
		}
		
		function handleScrollForMemories() {
			if (lastClickedMemory && !isInViewport(lastClickedMemory)) {
				resetMemory(lastClickedMemory);
				lastClickedMemory = null;
			}
		}

	
		// Utility: compute relative luminance for contrast
		function luminance([r, g, b]) {
			const srgb = [r, g, b].map(v => v / 255);
			const lin = srgb.map(v => (v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)));
			return 0.2126 * lin[0] + 0.7152 * lin[1] + 0.0722 * lin[2];
		}

		function contrastRatio(rgb1, rgb2) {
			const L1 = luminance(rgb1);
			const L2 = luminance(rgb2);
			const [hi, lo] = L1 > L2 ? [L1, L2] : [L2, L1];
			return (hi + 0.05) / (lo + 0.05);
		}

		function pickTextColor(bg1, bg2) {
			// Compare black vs white against average of the two bg colors
			const avg = [(bg1[0]+bg2[0])/2, (bg1[1]+bg2[1])/2, (bg1[2]+bg2[2])/2];
			const black = [0,0,0], white = [255,255,255];
			return contrastRatio(avg, white) >= contrastRatio(avg, black) ? '#ffffff' : '#111111';
		}

		// New, robust extractor
		function extractColorsAndCreateGradient(img, overlay) {
			try {
			if (typeof ColorThief === 'undefined') {
				console.warn('ColorThief not loaded');
				// Nice fallback
				overlay.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.75), rgba(139,92,246,0.75))';
				return;
			}

			const colorThief = new ColorThief();

			async function applyGradient() {
				try {
				// If the image is cached, decode ensures it's ready for pixel access
				if ('decode' in img) {
					try { await img.decode(); } catch {}
				}
				// Palette: [ [r,g,b], [r,g,b], ... ]
				const palette = colorThief.getPalette(img, 4, 12);
				if (!palette || palette.length < 2) {
					overlay.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.75), rgba(139,92,246,0.75))';
					overlay.style.color = '#ffffff';
					return;
				}

				const c1 = palette[0];
				const c2 = palette[1];

				const gradient = `linear-gradient(135deg,
					rgba(${c1[0]}, ${c1[1]}, ${c1[2]}, 0.80),
					rgba(${c2[0]}, ${c2[1]}, ${c2[2]}, 0.80)
				)`;

				overlay.style.background = gradient;
				overlay.style.color = pickTextColor(c1, c2);
				} catch (err) {
				console.error('applyGradient error:', err);
				overlay.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.75), rgba(139,92,246,0.75))';
				overlay.style.color = '#ffffff';
				}
			}

			if (img.complete && img.naturalWidth > 0) {
				applyGradient();
			} else {
				img.onload = applyGradient;
				img.onerror = () => {
				console.error('Image failed to load for gradient:', img.src);
				overlay.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.75), rgba(139,92,246,0.75))';
				overlay.style.color = '#ffffff';
				};
			}
			} catch (error) {
			console.error('Color extraction failed:', error);
			overlay.style.background = 'linear-gradient(135deg, rgba(236,72,153,0.75), rgba(139,92,246,0.75))';
			overlay.style.color = '#ffffff';
			}
		}



		document.addEventListener('DOMContentLoaded', function () {
			initializeMemoryInteractions();
		});

		(function () {
			// Date formatting util for attribution
			const fmt = new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
			const formatDate = (iso) => { try { return fmt.format(new Date(iso)); } catch { return ''; } };

			// Filters helpers
			function parseFiltersFromURL() {
				const sp = new URLSearchParams(location.search);
				const by = (sp.get('by') || 'all').toLowerCase();
				const sort = (sp.get('sort') || 'newest').toLowerCase();
				const after = sp.get('after') || '';
				const before = sp.get('before') || '';
				return {
					by: ['all','hannah','nathan','both'].includes(by) ? by : 'all',
					sort: ['newest','oldest'].includes(sort) ? sort : 'newest',
					after,
					before
				};
			}

			function applyFiltersToUI(f) {
				const bar = document.getElementById('filter-bar');
				if (!bar) return;
				bar.querySelectorAll('[data-by]')?.forEach(btn => btn.setAttribute('aria-pressed', String(btn.dataset.by === f.by)));
				bar.querySelectorAll('[data-sort]')?.forEach(btn => btn.setAttribute('aria-pressed', String(btn.dataset.sort === f.sort)));
				const after = document.getElementById('filter-after');
				const before = document.getElementById('filter-before');
				if (after) after.value = f.after || '';
				if (before) before.value = f.before || '';
			}

			function filtersToQueryString(f){
				const p = new URLSearchParams();
				if (f.by && f.by !== 'all') p.set('by', f.by);
				if (f.sort && f.sort !== 'newest') p.set('sort', f.sort);
				if (f.after) p.set('after', f.after);
				if (f.before) p.set('before', f.before);
				return p.toString();
			}

			function updateURL(f){
				const qs = filtersToQueryString(f);
				const url = qs ? `?${qs}` : location.pathname;
				history.replaceState(null, '', url);
			}

			function wireFilterBar(){
				const bar = document.getElementById('filter-bar');
				if (!bar) return;
				bar.addEventListener('click', (e) => {
					const byBtn = e.target.closest('[data-by]');
					const sortBtn = e.target.closest('[data-sort]');
					if (!byBtn && !sortBtn) return;
					const curr = parseFiltersFromURL();
					if (byBtn) curr.by = byBtn.dataset.by;
					if (sortBtn) curr.sort = sortBtn.dataset.sort;
					applyFiltersToUI(curr);
					updateURL(curr);
					loadAndRenderMemories(curr);
				});
				['filter-after','filter-before'].forEach(id => {
					const el = document.getElementById(id);
					if (!el) return;
					el.addEventListener('change', () => {
						const curr = parseFiltersFromURL();
						curr.after = document.getElementById('filter-after')?.value || '';
						curr.before = document.getElementById('filter-before')?.value || '';
						updateURL(curr);
						loadAndRenderMemories(curr);
					});
				});
			}
			function escapeHtml(s) {
				return (s || '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
			}

			function setupAddMemoryCard() {
				const grid = document.getElementById('memories-grid');
				
				// Handle clicking on add memory card
				grid.addEventListener('click', function(e) {
					const addCard = e.target.closest('.add-memory-card');
					if (!addCard) return;
					
					if (!addCard.classList.contains('expanded')) {
						// Expand the card
						addCard.classList.add('expanded');

						addCard.style.border = '2px solid var(--brand)';
						addCard.style.borderRadius = '0.5rem'; // keep rounded look (matches rounded-lg)


						addCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
					}
				});
				
				// Handle cancel button
				grid.addEventListener('click', function(e) {
					if (e.target.id === 'add-memory-cancel') {
						e.preventDefault();
						const addCard = e.target.closest('.add-memory-card');
						if (addCard) {
							addCard.classList.remove('expanded');
							// âœ… Remove brand border on collapse
							addCard.style.border = '';
							addCard.style.borderRadius = '';
							const form = addCard.querySelector('#add-memory-form');
							if (form) form.reset();
							const error = addCard.querySelector('#add-memory-error');
							if (error) error.style.display = 'none';
						}
					}
				});
				
				// Note: form submit handling is attached per-card when the add card is rendered.
			}

			async function loadAndRenderMemories(filters) {
				try {
					const f = filters || parseFiltersFromURL();
					const qs = (() => {
						const s = new URLSearchParams();
						if (f.by && f.by !== 'all') s.set('by', f.by);
						if (f.sort && f.sort !== 'newest') s.set('sort', f.sort);
						if (f.after) s.set('after', f.after);
						if (f.before) s.set('before', f.before);
						return s.toString();
					})();
					const r = await fetch('/api/list-memories' + (qs ? `?${qs}` : ''), { method: 'GET', credentials: 'same-origin' });
					if (!r.ok) return;
					const j = await r.json();
					if (!j.items) return;
					const main = document.getElementById('memories-grid');
					if (!main) return;

					main.innerHTML = '';

					j.items.slice().reverse().forEach((item, index) => {
						const div = document.createElement('div');
						div.className = 'memory relative group w-full h-full rounded-2xl overflow-hidden shadow-lg';
						div.tabIndex = 0;
						
						// Add AOS animation attributes
						div.setAttribute('data-aos', 'fade-up');
						div.setAttribute('data-aos-duration', '1000');
						div.setAttribute('data-aos-offset', '100');
						div.setAttribute('data-aos-delay', (index * 50).toString());
						
						const imageUrl = item.image_url || '';
						const titleText = item.title || '';
						const noteText = item.note || '';
						const authorName = item.author_name || 'Unknown';
						const whenISO = item.taken_at || item.created_at;
						const whenText = whenISO ? formatDate(whenISO) : '';
						
						// Create image element
						const img = document.createElement('img');
						// IMPORTANT: set crossOrigin BEFORE setting src, if your images are served with proper CORS headers
						img.crossOrigin = 'anonymous';
						img.alt = titleText;
						img.className = 'rounded-lg shadow-lg transition-transform duration-300 ease-in-out transform w-full h-auto hover:shadow-xl';
						img.src = imageUrl; // set src after crossOrigin
						
						// Create overlay
						const overlay = document.createElement('div');
						overlay.className = 'memory-overlay absolute inset-0 flex items-center justify-center';
						
						// Create content container
						const contentDiv = document.createElement('div');
						contentDiv.className = 'text-center px-4';
						
						const titleElement = document.createElement('h3');
						titleElement.className = 'text-white/95 text-2xl font-semibold mb-2';
						titleElement.textContent = titleText;
						
						const noteElement = document.createElement('p');
						noteElement.className = 'text-white/95 text-lg';
						noteElement.textContent = noteText;
						
						contentDiv.appendChild(titleElement);
						contentDiv.appendChild(noteElement);
						overlay.appendChild(contentDiv);
						
						div.appendChild(img);
						div.appendChild(overlay);

						// Attribution overlay
						const attrib = document.createElement('div');
						attrib.className = 'attribution-overlay pointer-events-none absolute inset-0 flex items-end p-3 opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition [background:linear-gradient(to_top,rgba(0,0,0,.55),rgba(0,0,0,0))]';
						attrib.setAttribute('aria-hidden', 'true');
						const attribSpan = document.createElement('span');
						attribSpan.className = 'text-white/95 text-xs sm:text-sm font-medium drop-shadow';
						attribSpan.textContent = whenText ? `Added by ${authorName} on ${whenText}` : `Added by ${authorName}`;
						attrib.appendChild(attribSpan);
						div.appendChild(attrib);
						
						// Extract colors and apply gradient after a short delay to ensure ColorThief is loaded
						setTimeout(() => {
							extractColorsAndCreateGradient(img, overlay);
						}, 500);
						
						main.appendChild(div);
					});
					
					// Add the "Add Memory" card at the end
					const addCard = document.createElement('div');
					addCard.className = 'add-memory-card rounded-lg flex flex-col items-center justify-center p-6';
					addCard.setAttribute('data-aos', 'fade-up');
					addCard.setAttribute('data-aos-duration', '1000');
					addCard.setAttribute('data-aos-offset', '100');
					addCard.setAttribute('data-aos-delay', (j.items.length * 50).toString());
					
					addCard.innerHTML = `
						<div class="add-memory-content flex flex-col items-center justify-center text-center">
							<div class="text-6xl mb-4 text-gray-400">âž•</div>
							<h3 class="text-xl font-semibold text-gray-600 mb-2">Add New Memory</h3>
							<p class="text-gray-500">Click to add a new memory to your collection</p>
						</div>
						<div class="add-memory-form w-full">
							<h3 class="text-lg font-semibold mb-4 text-center">Add New Memory</h3>
														<form id="add-memory-form" class="space-y-4">
								<input name="title" placeholder="Memory Title" class="w-full rounded border px-3 py-2" />
								<textarea name="note" placeholder="Tell the story of this memory..." class="w-full rounded border px-3 py-2 h-24 resize-none"></textarea>
								<input name="taken_at" type="date" class="w-full rounded border px-3 py-2" />
																<label class="block">
																	<span class="text-sm text-slate-600">Added by</span>
																	<select name="attribution_name" class="mt-1 w-full rounded border px-3 py-2">
																		<option value="Hannah">Hannah</option>
																		<option value="Nathan">Nathan</option>
																		<option value="Both">Both</option>
																	</select>
																</label>
								<input name="image" type="file" accept="image/*" class="w-full rounded border px-3 py-2" />
								<div class="flex justify-end gap-3">
									<button type="button" id="add-memory-cancel" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
									<button type="submit" class="px-6 py-2 bg-[var(--brand)] text-white rounded hover:bg-orange-400 transition-colors">Add Memory</button>
								</div>
								<p id="add-memory-error" class="text-red-600 text-sm" style="display:none"></p>
							</form>
						</div>
					`;
					
					main.appendChild(addCard);

							// Reinitialize AOS for new elements
							AOS.refresh();

							// Reinitialize memory interactions
							initializeMemoryInteractions();

							// Attach submit handler for this addCard AFTER interactions are initialized
							const form = addCard.querySelector('#add-memory-form');
							if (form) {
								const error = form.querySelector('#add-memory-error');
								const submitBtn = form.querySelector('button[type="submit"]');
								// create loading bar element
								const loadBar = document.createElement('div');
								loadBar.className = 'add-loading bg-orange-400 absolute left-0 bottom-0 w-0';
								addCard.appendChild(loadBar);

								form.addEventListener('submit', async function (e) {
									e.preventDefault();
									if (submitBtn) submitBtn.disabled = true;
									if (error) { error.style.display = 'none'; }

									const title = form.title.value;
									const note = form.note.value;
									const taken_at = form.taken_at.value || null;
									const file = form.image.files[0];
									if (!file) {
										if (error) { error.textContent = 'Please choose an image'; error.style.display = 'block'; }
										if (submitBtn) submitBtn.disabled = false;
										return;
									}

									// show initial loading indicator
									loadBar.style.width = '20%';

									const reader = new FileReader();
									reader.onload = async function () {
										try {
											loadBar.style.width = '50%';
											const imageBase64 = reader.result;
											const attribution_name = form.attribution_name ? form.attribution_name.value : null;
											const payload = { title, note, taken_at, attribution_name, is_private: false, imageBase64, filename: file.name };
											const r = await fetch('/api/import-old-memory', {
												method: 'POST',
												headers: { 'Content-Type': 'application/json' },
												credentials: 'same-origin',
												body: JSON.stringify(payload)
											});
											loadBar.style.width = '80%';
											const j = await r.json();
											if (!r.ok) {
												if (error) { error.textContent = j?.error || 'Upload failed'; error.style.display = 'block'; }
												loadBar.style.width = '0%';
												if (submitBtn) submitBtn.disabled = false;
												return;
											}
											// Success - show completion
											loadBar.style.width = '100%';
											setTimeout(async () => {
												// reload memories and reset
												await loadAndRenderMemories();
												// ensure add card handlers are set again
												setupAddMemoryCard();
											}, 300);
										} catch (err) {
											if (error) { error.textContent = 'Upload failed'; error.style.display = 'block'; }
											loadBar.style.width = '0%';
											if (submitBtn) submitBtn.disabled = false;
										}
									};
									reader.readAsDataURL(file);
								});
							}
					
				} catch (err) { console.error('loadAndRenderMemories failed', err); }
			}

			// Initialize everything
			const initialFilters = parseFiltersFromURL();
			applyFiltersToUI(initialFilters);
			wireFilterBar();
			loadAndRenderMemories(initialFilters).then(() => {
				setupAddMemoryCard();
			});
		})();
	</script>
</body>

</html>